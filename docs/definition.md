#基本概念
  **设计模式（Design pattern）**是一套在oop(面向对象编程)被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性

#基本原则：

##单一职责原则
	不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。

解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会消弱或者抑制这个类完成其他职责的能力。这中耦合会导致脆弱的设计，但变化发生时，设计会遭受到意想不到的破坏。
软件设计真正做的许多内容，就是发现职责并把他们相互分离。
如果你能够想到多于一个的动机去改变一个类，这个类就是具有多于一个的职责。 

##里氏替换原则
	所有引用基类的地方必须能透明地使用其子类的对象。

问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。

解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 “子类可以扩展父类的功能，但不能改变父类原有的功能”
 
只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。

正是由于子类型的可替换性才使得父类类型的模块在无需修改的情况下就可以扩展

##依赖倒置原则
	高层模块不应该依赖低层模块,二者都应该依赖其抽象,抽象不应该依赖细节,细节应该依赖抽象。

问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。

解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。“依赖倒置原则的核心思想是面向接口编程”
a.低层模块尽量都要有抽象类或接口，或者两者都有。
b.变量的声明类型尽量是抽象类或接口。
c.使用继承时遵循里氏替换原则

##接口隔离原则
	客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。

##迪米特法则
	一个对象应该对其他对象保持最少的了解。

问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。

解决方案：尽量降低类与类之间的耦合。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息

##开闭原则
	一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。“用抽象构建框架，用实现扩展细节”

无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化，既然不肯能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。

面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 

##合成/聚合复用原则
	优先使用对象组合，而非继承

>
聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。
组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。
在合成关系中，部分和整体的生命周期一样，组合的新的对象完全支配其组成部分，包括他们的创建和销毁。一个合成关系中成分对象是不能与另外一个合成关系共享。

问题由来：对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现。子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化
当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换这种依赖关系限制了灵活性，并最终限制了复用性

解决方案：如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种"；而"Has-A"则不同，它表示某一个角色具有某一项责任。


##总结
* 单一职责原则告诉我们实现类要职责单一
* 里氏替换原则告诉我们不要破坏继承体系
* 依赖倒置原则告诉我们要面向接口编程
* 接口隔离原则告诉我们在设计接口的时候要精简单一
* 迪米特法则告诉我们要降低耦合
* 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭


>
内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度
耦合性描述的是一个例程与其他例程之间的紧密程度
软件开发的目标是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。
